<!DOCTYPE html>
<!--
    ╔══════════════════════════════════════════════════════════════════╗
    ║                                                                  ║
    ║   Clever to inspect the page for clues. Think you're 1337?       ║
    ║                                                                  ║
    ║   We admire people who think outside the box. The fact that      ║
    ║   you're reading source tells us you might be our kind of        ║
    ║   person. Here's a nudge in the right direction.                 ║
    ║                                                                  ║
    ╠══════════════════════════════════════════════════════════════════╣
    ║                                                                  ║
    ║   ▸ EASY CHALLENGE                                               ║
    ║                                                                  ║
    ║     The command uses `tr` to perform character substitution.      ║
    ║     Study the two character sets passed to `tr`:                  ║
    ║       - The first set defines the input characters.              ║
    ║       - The second set defines what they map to.                 ║
    ║     Each character in the encoded string is swapped according    ║
    ║     to that mapping. You can work it out on paper, or just       ║
    ║     run the command in any Linux/macOS terminal.                  ║
    ║     Hint: the output is an email address.                        ║
    ║                                                                  ║
    ╠══════════════════════════════════════════════════════════════════╣
    ║                                                                  ║
    ║   ▸ HARD CHALLENGE                                               ║
    ║                                                                  ║
    ║     Each of the 15 qubits represents one character.              ║
    ║                                                                  ║
    ║     Step 1: Look at the α coefficient for each qubit.            ║
    ║             α is the real-valued amplitude of |0⟩.               ║
    ║                                                                  ║
    ║     Step 2: Recover the polar angle θ from α.                    ║
    ║             Recall that for a qubit on the Bloch sphere,         ║
    ║             α = cos(θ/2). So θ = 2 · arccos(α).                 ║
    ║                                                                  ║
    ║     Step 3: θ maps linearly to 7-bit ASCII space.                ║
    ║             The full range [0, π] maps to [0, 128].              ║
    ║             So: ASCII value = round(θ × 128 / π).                ║
    ║                                                                  ║
    ║     Step 4: Convert each ASCII value to its character.           ║
    ║             Concatenate all 15 characters in order.              ║
    ║             The result is an email address.                      ║
    ║                                                                  ║
    ║     That's it. No phase decoding needed — φ is a red herring.    ║
    ║     The answer lives entirely in θ.                              ║
    ║         Hint: Round up                                           ║
    ╠══════════════════════════════════════════════════════════════════╣
    ║                                                                  ║
    ║   Still stuck? We respect persistence.                           ║
    ║   Send what you've tried so far to careers@esrpo.com.            ║
    ║   Showing your work matters more than the answer.                ║
    ║                                                                  ║
    ╚══════════════════════════════════════════════════════════════════╝
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Careers - EchoSpark</title>
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">
    <link rel="icon" type="image/png" href="/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BP724NMT95"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BP724NMT95');
</script>
<body>
    <!-- Animated Background -->
    <div class="animated-bg">
        <div class="gradient-orb orb-1"></div>
        <div class="gradient-orb orb-2"></div>
        <div class="gradient-orb orb-3"></div>
    </div>

    <!-- Navigation -->
    <header class="header">
        <nav class="nav-container">
            <a href="index.html" class="logo-container">
                <svg class="logo-icon" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 5L35 12V28L20 35L5 28V12L20 5Z" stroke="url(#logoGradient)" stroke-width="2" fill="none" class="logo-path"/>
                    <path d="M20 9L22 20L18 20Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M20 31L22 20L18 20Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M31 20L20 18L20 22Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M9 20L20 18L20 22Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M27 13L21.5 21.5L18.5 18.5Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M27 27L21.5 18.5L18.5 21.5Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M13 27L18.5 18.5L21.5 21.5Z" fill="url(#logoGradient)" class="logo-center"/>
                    <path d="M13 13L18.5 21.5L21.5 18.5Z" fill="url(#logoGradient)" class="logo-center"/>
                    <circle cx="20" cy="20" r="1.5" fill="url(#logoGradient)" class="logo-center"/>
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#6366f1;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                </svg>
                <span class="logo-text">EchoSpark</span>
            </a>
            <ul class="nav-links">
                <li><a href="about.html" class="nav-link">About</a></li>
                <li><a href="index.html#domains" class="nav-link">Domains</a></li>
                <li><a href="careers.html" class="nav-link">Careers</a></li>
                <li><a href="index.html#contact" class="nav-link">Contact</a></li>
            </ul>
            <button class="menu-toggle" aria-label="Toggle Navigation">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </nav>
    </header>

    <!-- Careers Hero -->
    <section class="careers-hero">
        <div class="careers-content">
            <div class="careers-badge">
                <span class="badge-text">Careers</span>
            </div>
            <h1 class="careers-title">We only take the best.</h1>
            <p class="careers-subtitle">If you know, you know. If you don't, <strong style="color: var(--text-primary);">ESRPO</strong> isn't for you.</p>

            <!-- EASY CHALLENGE -->
            <div class="challenge-block">
                <div class="challenge-difficulty challenge-easy">Easy</div>
                <div class="terminal-block">
                    <div class="terminal-header">
                        <div class="terminal-dots">
                            <span class="terminal-dot dot-red"></span>
                            <span class="terminal-dot dot-yellow"></span>
                            <span class="terminal-dot dot-green"></span>
                        </div>
                        <span class="terminal-title"></span>
                    </div>
                    <div class="terminal-body">
                        <div class="terminal-line">
                            <span class="terminal-prompt">$</span>
                            <code class="terminal-command">s='zxobbop!bpoml#zlj'; printf '%s\n' "$s" |tr 'X-ZA-Wx-za-w!#' 'A-Za-z@.'</code>
                        </div>
                    </div>
                </div>
            </div>

            <!-- HARD CHALLENGE -->
            <div class="challenge-block">
                <div class="challenge-difficulty challenge-hard">Hard</div>
                <div class="quantum-challenge">
                    <p class="quantum-description">
                        A 15-qubit quantum register encodes an email address that reaches directly to the CEO of ESRPO. Each state 
                        |&#968;<sub>k</sub>&#10217; = &#945;<sub>k</sub>|0&#10217; + &#946;<sub>k</sub>|1&#10217; 
                        maps to exactly one character. The Bloch sphere's polar angle &#952; maps linearly 
                        from the computational basis to a 7-bit character space. Decode the register.
                    </p>

                    <!-- Bloch Sphere Visualization -->
                    <div class="bloch-wrapper">
                        <div id="blochSphere" class="bloch-container" style="min-height:450px;display:block;">
                            <div class="bloch-loading">Initializing quantum state space...</div>
                        </div>
                        <div class="bloch-controls-hint">Click and drag to rotate. Scroll to zoom.</div>
                    </div>

                    <!-- Quantum State Table -->
                    <div class="quantum-table-wrapper">
                        <table class="quantum-table">
                            <thead>
                                <tr>
                                    <th>Qubit</th>
                                    <th>&#945; &ensp;(|0&#10217; amplitude)</th>
                                    <th>&#946; &ensp;(|1&#10217; amplitude)</th>
                                </tr>
                            </thead>
                            <tbody id="quantumTableBody">
                                <!-- Populated by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-logo">
                <svg class="logo-icon" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 5L35 12V28L20 35L5 28V12L20 5Z" stroke="url(#footerLogoGradient)" stroke-width="2" fill="none"/>
                    <path d="M20 9L22 20L18 20Z" fill="url(#footerLogoGradient)"/>
                    <path d="M20 31L22 20L18 20Z" fill="url(#footerLogoGradient)"/>
                    <path d="M31 20L20 18L20 22Z" fill="url(#footerLogoGradient)"/>
                    <path d="M9 20L20 18L20 22Z" fill="url(#footerLogoGradient)"/>
                    <path d="M27 13L21.5 21.5L18.5 18.5Z" fill="url(#footerLogoGradient)"/>
                    <path d="M27 27L21.5 18.5L18.5 21.5Z" fill="url(#footerLogoGradient)"/>
                    <path d="M13 27L18.5 18.5L21.5 21.5Z" fill="url(#footerLogoGradient)"/>
                    <path d="M13 13L18.5 21.5L21.5 18.5Z" fill="url(#footerLogoGradient)"/>
                    <circle cx="20" cy="20" r="1.5" fill="url(#footerLogoGradient)"/>
                    <defs>
                        <linearGradient id="footerLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#6366f1;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                </svg>
                <span>EchoSpark</span>
            </div>
            <p class="footer-text">&copy; <span id="current-year">2026</span> EchoSpark. All rights reserved.</p>
        </div>
    </footer>

    <script src="script.js"></script>

    <!-- Quantum State Data + Pure Canvas Bloch Sphere (zero dependencies) -->
    <script>
    (function() {
        'use strict';

        // Precomputed quantum state angles [θ, φ] for 15 qubits
        var Q = [
            [2.478913, 2.061670],
            [2.847068, 4.172428],
            [2.552544, 1.227185],
            [2.380738, 1.079922],
            [2.699806, 5.841399],
            [1.570796, 3.976078],
            [2.478913, 2.061670],
            [2.822525, 2.356194],
            [2.797982, 0.539961],
            [2.748894, 3.190680],
            [2.724351, 1.374447],
            [1.129010, 2.699806],
            [2.429826, 4.712389],
            [2.724351, 1.374447],
            [2.675262, 4.025166]
        ];

        // Compute full state data from angles
        var states = Q.map(function(pair, i) {
            var theta = pair[0], phi = pair[1];
            var alpha = Math.cos(theta / 2);
            var sinHalf = Math.sin(theta / 2);
            var beta_r = sinHalf * Math.cos(phi);
            var beta_i = sinHalf * Math.sin(phi);
            var bx = Math.sin(theta) * Math.cos(phi);
            var by = Math.sin(theta) * Math.sin(phi);
            var bz = Math.cos(theta);
            return { index: i, theta: theta, phi: phi, alpha: alpha, beta_r: beta_r, beta_i: beta_i, bx: bx, by: by, bz: bz };
        });

        // Populate the state table
        var tbody = document.getElementById('quantumTableBody');
        if (tbody) {
            states.forEach(function(s) {
                var tr = document.createElement('tr');
                var sign = s.beta_i >= 0 ? '+' : '';
                tr.innerHTML =
                    '<td><span class="qubit-label">|&#968;<sub>' + s.index + '</sub>&#10217;</span></td>' +
                    '<td><code>' + (s.alpha >= 0 ? '+' : '') + s.alpha.toFixed(6) + '</code></td>' +
                    '<td><code>' + (s.beta_r >= 0 ? '+' : '') + s.beta_r.toFixed(6) + ' ' + sign + s.beta_i.toFixed(6) + 'i</code></td>';
                tbody.appendChild(tr);
            });
        }

        // ---- Pure Canvas 2D Bloch Sphere ----
        var container = document.getElementById('blochSphere');
        if (!container) return;

        container.innerHTML = '';
        var canvas = document.createElement('canvas');
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block';
        container.appendChild(canvas);

        var ctx = canvas.getContext('2d');
        var dpr = Math.min(window.devicePixelRatio || 1, 2);

        // Rotation state
        var rotX = -0.4;  // tilt
        var rotY = 0.6;   // spin
        var autoSpin = 0.003;
        var isDragging = false;
        var lastMX = 0, lastMY = 0;

        var dotColors = [
            '#f472b6', '#a78bfa', '#818cf8', '#6ee7b7', '#fbbf24',
            '#f87171', '#f472b6', '#67e8f9', '#34d399', '#fcd34d',
            '#c084fc', '#fb923c', '#60a5fa', '#c084fc', '#e879f9'
        ];

        function resize() {
            var w = container.clientWidth;
            var h = container.clientHeight;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
        }
        resize();

        // 3D rotation and projection
        function rotatePoint(x, y, z) {
            // Rotate around X axis
            var cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            var y1 = y * cosX - z * sinX;
            var z1 = y * sinX + z * cosX;
            // Rotate around Y axis
            var cosY = Math.cos(rotY), sinY = Math.sin(rotY);
            var x2 = x * cosY + z1 * sinY;
            var z2 = -x * sinY + z1 * cosY;
            return { x: x2, y: y1, z: z2 };
        }

        function project(x, y, z) {
            var w = canvas.width / dpr;
            var h = canvas.height / dpr;
            var r = Math.min(w, h) * 0.34;
            var cx = w / 2;
            var cy = h / 2;
            var p = rotatePoint(x, y, z);
            return { x: cx + p.x * r, y: cy - p.y * r, z: p.z, r: r };
        }

        function drawLine(x1, y1, z1, x2, y2, z2, color, alpha) {
            var a = project(x1, y1, z1);
            var b = project(x2, y2, z2);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha || 0.4;
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawCircle3D(segments, radius, axisPlane, color, alpha) {
            ctx.beginPath();
            for (var i = 0; i <= segments; i++) {
                var angle = (i / segments) * Math.PI * 2;
                var x = 0, y = 0, z = 0;
                if (axisPlane === 'xy') { x = Math.cos(angle) * radius; y = Math.sin(angle) * radius; }
                else if (axisPlane === 'xz') { x = Math.cos(angle) * radius; z = Math.sin(angle) * radius; }
                else if (axisPlane === 'yz') { y = Math.cos(angle) * radius; z = Math.sin(angle) * radius; }
                var p = project(x, y, z);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha || 0.15;
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawText(text, x, y, z, color, size) {
            var p = project(x, y, z);
            ctx.font = (size || 12) + 'px sans-serif';
            ctx.fillStyle = color || '#a1a1aa';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = 0.9;
            ctx.fillText(text, p.x, p.y);
            ctx.globalAlpha = 1;
        }

        function draw() {
            var w = canvas.width / dpr;
            var h = canvas.height / dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, w, h);

            // Draw wireframe circles
            drawCircle3D(64, 1, 'xy', '#6366f1', 0.12);
            drawCircle3D(64, 1, 'xz', '#6366f1', 0.08);
            drawCircle3D(64, 1, 'yz', '#6366f1', 0.08);

            // Draw axes
            drawLine(0, -1.3, 0, 0, 1.3, 0, '#ffffff', 0.35);   // Z (|0⟩ to |1⟩)
            drawLine(-1.3, 0, 0, 1.3, 0, 0, '#6366f1', 0.3);    // X
            drawLine(0, 0, -1.3, 0, 0, 1.3, '#8b5cf6', 0.3);    // Y

            // Axis labels
            drawText('|0⟩', 0, 1.5, 0, '#ffffff', 14);
            drawText('|1⟩', 0, -1.5, 0, '#ffffff', 14);
            drawText('+X', 1.5, 0, 0, '#6366f1', 11);
            drawText('+Y', 0, 0, 1.5, '#8b5cf6', 11);

            // Pole dots
            var p0 = project(0, 1, 0);
            var p1 = project(0, -1, 0);
            ctx.beginPath(); ctx.arc(p0.x, p0.y, 3, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill();
            ctx.beginPath(); ctx.arc(p1.x, p1.y, 3, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill();

            // Sort state points by z-depth for proper layering
            var points = states.map(function(s, i) {
                // Bloch coords: bx, by, bz where bz is the Z axis (|0⟩ up)
                // Map to 3D scene: scene X = bloch bx, scene Y = bloch bz (up), scene Z = bloch by
                var p = rotatePoint(s.bx, s.bz, s.by);
                return { state: s, index: i, depth: p.z };
            });
            points.sort(function(a, b) { return a.depth - b.depth; });

            // Draw state vectors
            points.forEach(function(pt) {
                var s = pt.state;
                var i = pt.index;
                var color = dotColors[i % dotColors.length];

                // Line from center to point
                var center = project(0, 0, 0);
                var tip = project(s.bx, s.bz, s.by);
                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.lineTo(tip.x, tip.y);
                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Dot
                var depthFade = 0.5 + 0.5 * ((pt.depth + 1) / 2);
                var dotSize = 4 + 3 * depthFade;
                ctx.beginPath();
                ctx.arc(tip.x, tip.y, dotSize, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = depthFade;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Index label
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#e2e8f0';
                ctx.globalAlpha = Math.max(0.3, depthFade);
                ctx.textAlign = 'center';
                ctx.fillText(i, tip.x, tip.y - dotSize - 4);
                ctx.globalAlpha = 1;
            });
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMX = e.clientX;
            lastMY = e.clientY;
            autoSpin = 0;
        });
        window.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            var dx = e.clientX - lastMX;
            var dy = e.clientY - lastMY;
            rotY += dx * 0.008;
            rotX += dy * 0.008;
            rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
            lastMX = e.clientX;
            lastMY = e.clientY;
        });
        window.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                autoSpin = 0.003;
            }
        });

        // Touch interaction
        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMX = e.touches[0].clientX;
                lastMY = e.touches[0].clientY;
                autoSpin = 0;
                e.preventDefault();
            }
        }, { passive: false });
        canvas.addEventListener('touchmove', function(e) {
            if (!isDragging || e.touches.length !== 1) return;
            var dx = e.touches[0].clientX - lastMX;
            var dy = e.touches[0].clientY - lastMY;
            rotY += dx * 0.008;
            rotX += dy * 0.008;
            rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
            lastMX = e.touches[0].clientX;
            lastMY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchend', function() {
            if (isDragging) {
                isDragging = false;
                autoSpin = 0.003;
            }
        });

        // Animation loop
        function animate() {
            rotY += autoSpin;
            draw();
            requestAnimationFrame(animate);
        }
        animate();

        // Responsive resize
        window.addEventListener('resize', function() { resize(); });
        new ResizeObserver(function() { resize(); }).observe(container);

    })();
    </script>
</body>
</html>
